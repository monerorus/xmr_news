---
title: "Журнал встречи исследовательской лаборатории Monero 2019-02-09​"
date: 2019-02-09
id: 1
draft: false    
categories: [logs, mrl]
---

>  _**hyc:**_ Я думал, что эта идея randomJS PoW была довольно крутой, когда я придумывал ее  
>  _<-- sgp\_1 (~justi@50-202-180-242-static.hfc.comcastbusiness.net) покинул #monero-research-lab  
>  --> sgp\_ (~justi@50-202-180-242-static.hfc.comcastbusiness.net) подключился_ _к #monero-research-lab  
>  **gmaxwell:**_ hyc: такой подход полностью разрушался всякий раз, когда я видел его предложенным ранее (по крайней мере, в 2012 году)  
>  _**gmaxwell:**_ как правило, одним из необходимых свойств для хорошего POW является то, что каждый экземпляр одинаково трудно выполнить в наиболее оптимизированной среде  
>  _<-- muff1nman (~irccc@75-166-29-132.hlrn.qwest.net) вышел (Причина: нет ответа в течение 180 секунд)  
>  **hyc:**_ да, только насколько сложен этот код, определяющий "супер-тривиальность"  
>  _**hyc:**_ генератор кода настроен так, чтобы сохранить весь сгенерированный код в течение времени выполнения (x +/- 10 миллисекунд)  
>  _**endogenic:**_ hyc: какие изменения могут быть внесены в randomjs, если выяснится, что некоторые его аспекты были реализованы аппаратно?  
>  _**andytoshi:**_ я ожидал бы, что это сделает сопоставление с шаблоном и возьмет однозначные числа наносекунд  
>  _--> muff1nman (~irccc@75-166-29-132.hlrn.qwest.net) подключился_ _к #monero-research-lab  
>  **hyc:**_ andytoshi: Я очень сильно сомневаюсь в этом, поскольку сгенерированный код включает в себя вызовы exec ("") со случайно сгенерированным кодом  
>  _**hyc:**_ на самом деле это потребует выполнения JS, обойти это невозможно  
>  _**gmaxwell:**_ знаменитые последние слова  
>  _**hyc:**_ количество перестановок просто астрономическое, есть шаблон для всего этого?  
>  _**hyc:**_ независимо от того, какую именно оптимизацию мы получим, требуемая схема будет намного тяжелее, чем ASIC Cryptonight  
>  _**hyc:**_ большая площадь микросхемы, более высокая мощность, более низкий коэффициент полезного действия  
>  _**hyc:**_ как вы собираетесь оптимизировать инструкции? вам понадобится CPU предсказатель ответвлений  
>  _**endogenic:**_ не уверен, что ваши рассуждения верны, когда у нас есть крупные игроки со стимулом и возможностями для производства JS чипа  
>  _**hyc:**_ endogenic: это все равно победа  
>  _**endogenic:**_ я не эксперт в этом ..  
>  _**andytoshi:**_ hyc: это действительно звучит так, что люди нашли легкие пути  
>  _**endogenic:**_ это еще не победа, если у нас нет быстрого способа изменить это, когда появится следующая угроза  
>  _**hyc:**_ если JS чип становится коммодитизированным, выигрывают все  
>  _**andytoshi:**_ и дешево идентифицируемые слабые подмножества  
>  _**hyc:**_ andytoshi: Я не понимаю, как анализ кода может быть значительно дешевле  
>  _**hyc:**_ посмотрите на современное состояние инструментов анализа кода, таких как Coverity или Veracode. Они изобилуют ложными срабатываниями и поддельными результатами.  
>  _**hyc:**_ и это всё только для языка, как C, с небольшим набором ключевых слов и семантики  
>  _--> doubletwist25 (~doubletwi@41.218.203.121) подключился_ _к#monero-research-lab  
>  **andytoshi:**_ верно, вы не заботитесь о ложных негативах (в пределах разумного), и при всём этом вы не заботитесь о глубине анализа, который вам понадобится для проведения полезного статического анализа для логических ошибок  
>  _**andytoshi:**_ также C в основном UB  
>  _**andytoshi:**_ так что для меня не сразу понятно, что это будет легче, чем JS  
>  _**hyc:**_ по сути, вы говорите о написании декомпилятора для преобразования сгенерированного синтаксического дерева в макрооперации  
>  _**hyc:**_ и каким-то образом настройка таблицы поиска, которая может направлять поток к различным обработчикам шаблонов  
>  _<-- valentinbuza_ (~valentinb@unaffiliated/valentinbuza) вышел (Время бездействия 252 секунды)  
>  **hyc:**_ это все равно будет интерпретатором для токенизированного языка, вы просто говорите, что некоторые из токенов могут быть макромасштабными  
>  _**andytoshi:**_ да, и если вы можете сделать это за 0,1% времени, необходимого для фактического выполнения кода, но это работает только в 0,1% времени, тогда всё настроено  
>  _**andytoshi:**_ а остальные 99,9% времени вы просто отвергаете однократно используемое число  
>  _**hyc:**_ это самоубийство, так как выигрышное однократно используемое число с большей вероятностью будет на 99,9% в последовательности кода, которую вы отклонили  
>  _**gmaxwell:**_ andytoshi: именно так я и сломал свой POW  
>  _**andytoshi:**_ hyc: нет «победившего однократного используемого числа», только некоторая доля одноразовых номеров, которые приводят к действительному  
>  _**gmaxwell:**_ hyc: «победившее однократно используемое число» звучит как общее фундаментальное недоразумение в POW.  
>  _<-- doubletwist25 (~doubletwi@41.218.203.121) вышел (Время бездействия 272 секунды)  
>  **hyc:**_ конечный результат должен иметь XXXX байтов ниже, чем сложность  
>  _**gmaxwell:**_ Майнинг - это «найти иголку в стоге сена», а это решение «найти самую короткую соломинку в куче соломы»  
>  _**gmaxwell:**_ hyc: таких решений бесконечное множество  
>  _**andytoshi:**_ количество пропущенных однократно используемых чисел будет в 999 раз больше, чем число одноразовых номеров, которые я не пропущу  
>  _**andytoshi:**_ но это нормально, потому что я трачу намного меньше времени на пропущенные  
>  _**gmaxwell:**_ Я бы посоветовал прочитать статью по equihash’у с описанием того, что нужно, чтобы сделать хороший POW (не то чтобы equihash’у это удалось реализовать, авторы просто хорошо понимали, что требуется, но у них были неверные представления о том, как работает конечное оборудование)  
>  _**hyc:**_ для хэша блока есть только небольшое количество допустимых одноразовых номеров  
>  _**hyc:**_ хм, я читал про equihash, да.  
>  _**gmaxwell:**_ hyc: процесс майнинга не просто меняет диапозон однократно используемого числа, в противном случае он будет зависать и никогда не будет решен  
>  _**gmaxwell:**_ Если вы не нашли решения при поиске в одноразовых номерах, вы просто переходите к более большому диапозону  
>  _**hyc:**_ это верно, что для данного хэша блока, не может быть решения  
>  _**andytoshi:**_ вы имеете в виду "для данного заголовка блока без одноразового номера"  
>  _**hyc:**_ да  
>  _**andytoshi:**_ но вы можете изменить другие части заголовка блока  
>  _**gmaxwell:**_ поэтому кардинально неправильно думать в разрезе термина "только небольшого числа действительных одноразовых номеров"  
>  _**andytoshi:**_ например, bitcoin, где фактическое поле "действительных одноразовых номеров" составляет всего 32 бита  
>  _**hyc:**_ вы можете изменить временную метку и изменить сочетание txns, используемые для генерации заголовка  
>  _**moneromooo:**_ Я думаю, что вы можете просто помахать руками и не особо заморачиваться о том, что что-нибудь изменится, и потом назвать это "однократно используемым числом". Достаточно близко по смыслу и не коверкает суть теории  
>  _**gmaxwell:**_ moneromooo: в точности!  
>  _**hyc:**_ вы не знаете, что вам нужно что-то изменить, если вы уже не исчерпали одноразовое пространство  
>  _**gmaxwell:**_ hyc: конечно, и что?  
>  _**gmaxwell:**_ hyc: moneromooo, дело в том, что поскольку вы можете изменить другие параметры, одноразовое пространство фактически не ограничено. Да, вы разделяете его на две части, но с точки зрения анализа это не имеет большого значения.  
>  _**moneromooo:**_ О, сгенерированная программа зависит от фактического одноразового числа, верно? Таким образом, вы можете сохранить то же самое одноразовое число, а затем перебирать другие вещи (например, non-nonce tx_extra garbage).  
>  _**gmaxwell:**_ кроме того, обновление одной части несколько дороже, но поскольку вы будете выполнять огромное количество проверок для быстро обновляемой части, амортизируется, как правило, более дорогая часть.  
>  _**moneromooo:**_ Таким образом, вы можете выполнить анализ программы один раз  
>  _**hyc:**_ moneromooo: сгенерированная программа зависит от всего заголовка, включая одноразовое число  
>  _**hyc:**_ вы не можете повторно использовать любой похожий анализ  
>  _**moneromooo:**_ OK, просто игнорируйте меня ^_^  
>  _**hyc:**_ заголовок с одноразовым номером хэшируется, результат хеширования передается PRNG  
>  _**hyc:**_ Equihash также требует памяти, которая является быстро развивающимся решением. Технологии памяти продвигается гораздо быстрее, чем скорости процессора  
>  _**hyc:**_ Это обреченный подход с самого начала  
>  _**gmaxwell:**_ Я согласен, что это плохая идея, но причина, по которой вы даете это суждение, своего рода помешательство: "технологии памяти продвигается гораздо быстрее, чем скорости процессора", просто исторически сложилось все совсем наоборот... память развивалась намного-намного медленнее, чем скорости процессора.  
>  _**hyc:**_ емкость удваивается быстрее, чем скорость процессора  
>  _**gmaxwell:**_ Эти функции не являются «ресурсоемкими по емкости», а скорее, ресурсоемкими по пропускной способности  
>  _**hyc:**_ на самом деле скорость процессора в течение последних нескольких лет оставалась неизменной, и сейчас она снижается из-за уязвимостей  
>  _**hyc:**_ если вы уменьшите используемое пространство памяти, работа ускорится более чем в 2 раза  
>  _**hyc:**_ если вы уменьшаете требуемое пространство...  
>  _**gmaxwell:**_ Кроме того, (xkcd386) самая дешевая память тоже прогрессирует очень медленно...  
>  _**gmaxwell:**_ (по крайней мере, в последние годы)  
>  _**gmaxwell:**_ https://people.xiph.org/~greg/temp/memoryprices.png < Я сделал тебе график.  
>  _**gmaxwell:**_ это последнее десятилетие  
>  _--> valentinbuza_ (~valentinb@unaffiliated/valentinbuza) подключился к #monero-research-lab  
>  --> sfhi (~sfhi@1e.94.7a9f.ip4.static.sl-reverse.com) подключился_ _к #monero-research-lab  
>  **hyc:**_ хммм. Я думаю, что это результат физически уничтоженных заводов, а не технологических тенденций.  
>  _**gmaxwell:**_ прогресс на вычисление/$ был НАМНОГО лучше. ... это выглядит примерно так, как если вы зададите для вычисления/$ логарифмический масштаб вместо линейного, как на этом графике  
>  _**andytoshi:**_ memory_speed_ прогрессировала за период времени, когда $/мегабайт оставался неизменным  
>  _**gmaxwell:**_ andytoshi: да, но улучшение пропускной способности все еще шутка по сравнению с компьютерными улучшениями.  
>  _**hyc:**_ вычислительная стоимость: http://image.slidesharecdn.com/jsu-feb6-2016-160206014218/95/big-data-hpc-convergence-and-a-bunch-of-other-things-18-638.jpg?cb=1454723352  
>  _**hyc:**_ стоимость хранения: http://image.slidesharecdn.com/jsu-feb6-2016-160206014218/95/big-data-hpc-convergence-and-a-bunch-of-other-things-19-638.jpg?cb=1454723352  
>  _**andytoshi:**_ я больше пытаюсь оправдать все деньги, которые я потратил на оперативную память, чем пытаюсь внести свой вклад в разговор ;)  
>  _**hyc:**_ LOL  
>  _**gmaxwell:**_ главное заключается в том, что ограничения пропускной способности памяти - это не столько фундаментальное свойство памяти, сколько свойство фундаментальных характеристик источника ввода-вывода для чипа. Поместите память в чип, и пропускная способность возрастет в 100 раз без каких-либо других технических улучшений  
>  _**hyc:**_ стоимость хранения снижается на 38% в год по сравнению с вычислительной мощностью 33% в год  
>  _**hyc:**_ Я думаю, что никто не сказал этим парням о HBM  
>  _**gmaxwell:**_ Хранение= RAM, хотя, да, сверхурочные затраты на хранение исторически улучшились намного лучше, чем вычислительная мощность  
>  _<-- muff1nman (~irccc@75-166-29-132.hlrn.qwest.net) вышел (Время бездействия 180 секунд)  
>  --> el00ruobuob\_\[m\] (~el00ruobu@blabour.fr) подключился_ _к #monero-research-lab  
>  --> thelinuxguy7 (~thelinuxg@174-17-128-182.phnx.qwest.net) подключился_ _к #monero-research-lab  
>  **gmaxwell:**_ hyc: eldyentyrell, размещенный на github zcash, в основном указывает на пакет, прикрепленный к ram, tsvs и т.д… но они проигнорировали его  
>  _**hyc:**_ удивительный ответ...  
>  _**gmaxwell:**_ это то, что вы получаете, когда сами назначаете экспертов по узким областям разработки чего-то подобного, без участия тех людей, которые были бы ответственны за его оптимизацию (инженеров)  
>  _**gmaxwell:**_ с тех пор комментарий был удален, в противном случае я бы дал ссылку на него.  
>  _--> muff1nman (~irccc@75-166-29-132.hlrn.qwest.net) подключился_ _к #monero-research-lab  
>  **hyc:**_ кстати, Andytoshi, может быть, пришло время снова разориться на еще один DRAM https://press.trendforce.com/press/20180926-3163.html  
>  _--> midipoet (uid316937@gateway/web/irccloud.com/x-phbbtmjglhzxrinb) подключился_ _к #monero-research-lab  
>  **gmaxwell:**_ В любом случае ребята из equihash понимали, что нужно, но не понимали, с каким оборудованием им предстоит работать... это лучше, чем большинство других проектов, которые потерпели неудачу в обеих областях  
>  _--> jwheare10 (~jwheare@85.97.10.51) подключился_ _к #monero-research-lab  
>  **andytoshi:**_ hyc: моя дилемма заключается в том, что 14-дюймовые ThinkPad-ы имеют материнские платы, которые ограничены 32Gb уже в течение примерно 6 лет  
>  _**hyc:**_ Да, я это подметил. Я сам приглядывался к a485  
>  _**gmaxwell:**_ andytoshi: для компьютеров на базе xeon потребуется все 64 :p  
>  _<-- thelinuxguy7 (~thelinuxg@174-17-128-182.phnx.qwest.net) вышел (Удаленный хост прервал соединение)  
>  **knaccc:**_ Lenovo’s ThinkPad X1 Extreme: шесть ядер, GTX 1050 Ti, 64GB RAM и весит почти 2 килограмма  
>  _**hyc:**_ gmaxwell: так вы верите, что память - все еще жизнеспособный подход к проблеме? принимая во внимание встроенную память?  
>  _**gmaxwell:**_ hyc: Я думаю, что этого никто не знает. В общем, память можно рассматривать как конкретный случай «предоплаты по стоимости», и я думаю, что есть хорошие аргументы в пользу того, почему «предоплата по стоимости» является плохим решением как для POW, так и для случая с защитой паролем (хоть и совсем по разным причинам).  
>  _**gmaxwell:**_ По сути, при предельной стоимости вы платите много, чтобы купить атаку, но амортизированная стоимость после этого низкая. Так что это только благоприятствует первопроходцам  
>  _**gmaxwell:**_ Доказательство покупки, а не доказательство работы :p  
>  _<-- jwheare10 (~jwheare@85.97.10.51) вышел (Удаленный хост прервал соединение)  
>  **hyc:**_ казалось бы, но это правда, даже если бы мы были в мире, где всем управляет только процессор  
>  _**hyc:**_ первопроходцы просто скупают большинство мощностей процессоров  
>  _**gmaxwell:**_ Я думаю, что попытка прировнять все только cpu в основном является проигранной... с одной стороны, это огромная субсидия на патентные права на работу процессора, а не на материальные затраты, а это означает, что какой-нибудь хакер, будет иметь преимущество. Кроме того, независимо от того, какова функция «только для процессора», кто-то может создать специальный процессор для майнинга, который удаляет ненужные части (например, шины pcie) и использует изрядно меньше энергии  
>  _**gmaxwell:**_ например, в Силиконовой долине. В лучшем случае вы могли бы сделать оптимизированное оборудование только в 2 раза энергоэффективнее и в 10 раз эффективнее по производительности, но в разрезе майнинга (по крайней мере) такое оборудование в конечном итоге будет вытеснено из бизнеса.  
>  _**gmaxwell:**_ (Пираты или сами компании, конечно)  
>  _**knaccc:**_ разве экономия масштаба не влияет на такие вещи?  
>  _**hyc:**_ Я думаю, это слишком пессимистично. На автономном сервере, предназначенном для майнинга, ALU будут заняты 100% времени, а внешние шины будут простаивать  
>  _**gmaxwell:**_ Я гораздо больше надеюсь на полезность причудливых функций именно для защиты паролей, чем для майнинга. Я полагаю, что для майнинга делать специализированные вещи довольно "просто", 2x/10x будут более эффективными на коротком промежутке, чем в долгосрочной перспективе, но для безопасности паролей это отличное решение  
>  _**hyc:**_ специальному майнинговому чипу по-прежнему нужен канал связи для ввода и вывода данных.  
>  _**gmaxwell:**_ hyc: Я не знаю о других примеров, но бездействующие контроллеры pci-e в epyc потребляют около 4 Вт. (в качестве примера)  
>  _**hyc:**_ этот канал связи будет иметь примерно такое же использование, как и шины на сервере.  
>  _**gmaxwell:**_ майнинговый чип нуждается в консервной банке и веревке с мылом для ввода и вывода данных. Это несравнимо с гигабайтной шиной :)  
>  _**hyc:**_ конечно, но эта гигабайтная шина включается только на микросекунду  
>  _**knaccc:**_ что может пойти не так, если мы попробуем идею hyc для нескольких циклов обновления Monero? кажется, что у этой идеи большой потенциал  
>  _**hyc:**_ самое худшее, что может случиться через несколько месяцев – это новый ASIC  
>  _**knaccc:**_ да, и поэтому мы возвращаемся к чему-то другому, никакого реального ущерба  
>  _**knaccc:**_ или сделать его гибридным, так что каждый четвертый блок требует идеи hyc, а затем увеличивается в зависимости от реакции  
>  _**hyc:**_ ущерб заключается в том, что у нас не будет запасного алгоритма для следующего обновления после этого  
>  _**moneromooo:**_ Хуже всего то, что кто-то найдет скрытый или потайной подход к этому и поработит 99% сети  
>  _**hyc:**_ невозможно заполучить 99% и не наследить...  
>  _**gmaxwell:**_ knaccc: необоснованный аргумент  
>  _**gmaxwell:**_ один из недостатков в том, что такие люди, как я, начинают думать, что monero больше похож на ethereum с точки зрения архитектуры (пилим сук, на котором сидим)  
>  _**moneromooo:**_ Да, мы обязательно заметим. И моя точка зрения заключается в том, что у производителя ASIC устройств будет стимул сохранить сеть "без видимых изменений"  
>  _**knaccc:**_ ахахаха, пилить сук, отличная формулировка  
>  _**gmaxwell:**_ (FWIW и ethereum предложил аналогичный POW, когда RNG выбрал случайную цепь, и они отказались от нее после того, как было показано, что она будет сломана из-за тех же планируемых оптимизаций)  
>  _**hyc:**_ Вы говорите о чем-то до ProgPoW?  
>  _**gmaxwell:**_ да, задолго до их запуска  
>  _**hyc:**_ можете ли вы мне дать ссылку на это обсуждение?  
>  _**gmaxwell:**_ оригинальный хеш построил случайную арифметическую схему над 256-битными целыми числами  
>  _--> Trieste24 (~Trieste@mx-ll-180.183.136-35.dynamic.3bb.co.th) подключился_ _к #monero-research-lab  
>  <-- Trieste24 (~Trieste@mx-ll-180.183.136-35.dynamic.3bb.co.th) вышел (Удаленный хост прервал соединение)  
>  **gmaxwell:**_ кажется, они исчезли из многих публичных документов, вы можете увидеть это на данной странице : http://nbviewer.jupyter.org/gist/anonymous/cb53d06b837be97ebe32  
>  _**hyc:**_ спасибо  
>  _**gmaxwell:**_ (который показывал изначально 64 бит, но я уверен, что это было 256 бит, и в какой-то момент они просто изменили его)  
>  _**gmaxwell:**_ да, это должно быть более поздняя версия, в первой версии были инструкции, такие как div и mod.  
>  _**endogenic:**_ "самое худшее, что может случиться через несколько месяцев – это новый ASIC" < вы также потеряете много месяцев на развитие ASIC сопротивления, в то время как простые майнеры будут умолять вас о переключении назад  
>  _**hyc:**_ текущий алгоритм вообще не является устойчивым к ASIC, это просто изменения, чтобы вывести из строя существующие ASIC  
>  _**hyc:**_ эта «случайная схема» довольно тривиальна  
>  _**gmaxwell:**_ Он является общим для всех вычислений, поэтому я не думаю, что вы можете сказать, что это менее "тривиально", чем что-либо еще. Дополнительные сложности могут возникнуть, только если мы сами запутаемся.  
>  _**knaccc:**_ В конце концов, я предсказываю, что все правительства мира выдадут каждому гражданину уникальную асимметричную пару ключей, опубликуют список всех выпущенных ключей, чтобы их количество было известно, и тогда нам больше не будет нужен сам принцип доказательства работы  
>  _**hyc:**_ Разница между теорией и практикой - в теории алгоритмы X и Y могут быть сопоставимы, в то время как на практике одно гораздо легче реализовать, чем другое  
>  _**gmaxwell:**_ knaccc: привет, Майк Херн  
>  _**knaccc:**_ хаха, о, это то, на что он тоже надеется  
>  _**gmaxwell:**_ knaccc: «доказательство паспорта» было то, что он хотел реализовать  
>  _**hyc:**_ он библейский толкователь из книги откровений?  
>  _**knaccc:**_ интересно, спасибо, я буду гуглить  
>  _**hyc:**_ что бы победить все анонимные криптовалюты  
>  _**gmaxwell:**_ hyc: Если вы посмотрите на X и скажете, что это тривиально, но затем мы смотрим на Y и понимаем, что Y доказуемо идентичен к X, не должно ли вас беспокоить, что Y получается также аналогично тривиален?  
>  _**knaccc:**_ hyc: пара ключей будет использоваться только для "майнинга", а не в качестве ключей кошелька  
>  _**hyc:**_ да, это верный момент  
>  _**hyc:**_ Я бы сказал, что поскольку входные данные в конечном итоге одинаковы, диапазон перестановок также может быть одинаковым  
>  _**endogenic:**_ у monero была бы возможность узнать что-то о приближающейся опасности ASIC на том моменте, когда мы столкнулись с проблемой ручной настройки алгоритма  
>  _**hyc:**_ Я имею в виду, мы знаем, что PRNG не могут создавать энтропию, так что все может оказаться просто бессмысленным оформлением пустых витрин  
>  _**hyc:**_ оборотная сторона аргумента в том, что существующие алгоритмы не смогли выдавить столько перестановок, сколько могли бы  
>  _**hyc:**_ если мы можем сказать, что эти 2^256 могут быть уменьшены до 2^32 уникальных шаблонов, мы все равно создадим проблему, которая будет намного сложнее для разработчика ASIC  
>  _**endogenic:**_ насколько это будет сложнее для нас?  
>  _**hyc:**_ с процессором? это не будет большим недостатком  
>  _**endogenic:**_ но какие изменения в него можно внести?  
>  _**gmaxwell:**_ hyc: Я совершенно с этим не согласен  
>  _**gmaxwell:**_ Разработчик ASIC будет смотреть на 2^32 уникальных шаблона и находить большой подкласс, который довольно дешево будет реализовать, а затем просто заставлять свой чип преобразовывать работу  
>  _**hyc:**_ мы могли бы смоделировать это прямо сейчас, изменить случайный JS Impl и прервать его на 90%  
>  _**gmaxwell:**_ hyc: и будет в 1000 раз быстрее на оставшихся 10% ...  
>  _**endogenic:**_ ^  
>  _**hyc:**_ конечно, мы можем заменить его с 10 наносекунд сна  
>  _**hyc:**_ хм, нет, нам все еще нужно, чтобы он выдал действительный вывод для случаев, которые он фактически выполняет  
>  _**hyc:**_ вместо этого нам пришлось бы замедлить обычную реализацию  
>  _**hyc:**_ но это бы хорошо работало, мы также можем изменить коэффициент задержки и посмотреть, где находится точка безубыточности  

---
_Источник: [Logs for the Research Lab Meeting Held on 2019.02.09](https://pastebin.com/spug4a8x)  
Перевод: [Unholy](https://xmr.ru/members/754/)  
Редактирование: [Mr. Pickles](https://xmr.ru/members/50/) (@v1docq47)  
Коррекция: [Kukima](https://xmr.ru/members/138/)_